!<arch>
__.PKGDEF       0           0     0     644     14989     `
go object windows amd64 go1.6.2 X:none
build id "7608ded0b2ce746cf953b796fd4a0a2bd9373458"

$$
package luaLib
	const @"".LibAerospike = "\n\n-- The Lua Interface to Aerospike\n--\n-- ======================================================================\n-- Copyright [2014] Aerospike, Inc.. Portions may be licensed\n-- to Aerospike, Inc. under one or more contributor license agreements.\n--\n-- Licensed under the Apache License, Version 2.0 (the \"License\");\n-- you may not use this file except in compliance with the License.\n-- You may obtain a copy of the License at\n--\n--  http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n-- ======================================================================\n\n-- A table to track whether we had sandboxed a function\nsandboxed = {}\n\nldebug = debug;\n\n-- ############################################################################\n--\n-- LOG FUNCTIONS\n--\n-- ############################################################################\n\nfunction trace(m, ...)\n    return aerospike:log(4, string.format(m, ...))\nend\n\nfunction debug(m, ...)\n    return aerospike:log(3, string.format(m, ...))\nend\n\nfunction info(m, ...)\n    return aerospike:log(2, string.format(m, ...))\nend\n\nfunction warn(m, ...)\n    return aerospike:log(1, string.format(m, ...))\nend\n\n-- ############################################################################\n--\n-- APPLY FUNCTIONS\n--\n-- ############################################################################\n\n--\n-- Creates a new environment for use in apply_record functions\n--\nfunction env_record()\n    return {\n\n        -- aerospike types\n        [\"record\"] = record,\n        [\"iterator\"] = iterator,\n        [\"list\"] = list,\n        [\"map\"] = map,\n        [\"bytes\"] = bytes,\n        [\"aerospike\"] = aerospike,\n\n        [\"putX\"] = putX,\n\n        -- logging functions\n        [\"trace\"] = trace,\n        [\"debug\"] = debug,\n        [\"info\"] = info,\n        [\"warn\"] = warn,\n        \n        -- standard lua functions\n        [\"collectgarbage\"] = collectgarbage,\n        [\"error\"] = error,\n        [\"getmetatable\"] = getmetatable,\n        [\"ipairs\"] = ipairs,\n        [\"load\"] = loadstring,\n        [\"module\"] = module,\n        [\"next\"] = next,\n        [\"pairs\"] = pairs,\n        [\"print\"] = print,\n        [\"pcall\"] = pcall,\n        [\"rawequal\"] = rawequal,\n        [\"rawget\"] = rawget,\n        [\"rawset\"] = rawset,\n        [\"require\"] = require,\n        [\"require\"] = require,\n        [\"select\"] = select,\n        [\"setmetatable\"] = setmetatable,\n        [\"setfenv\"] = setfenv,\n        [\"tonumber\"] = tonumber,\n        [\"tostring\"] = tostring,\n        [\"type\"] = type,\n        [\"unpack\"] = unpack,\n        [\"xpcall\"] = xpcall,\n\n        -- standard lua objects\n        [\"math\"] = math,\n        [\"io\"] = io,\n        [\"os\"] = {\n            ['clock'] = os.clock,\n            ['date'] = os.date,\n            ['difftime'] = os.difftime,\n            ['getenv'] = os.getenv,\n            ['setlocale'] = os.setlocale,\n            ['time'] = os.time,\n            ['tmpname'] = os.tmpname\n        },\n        [\"package\"] = package,\n        [\"string\"] = string,\n        [\"table\"] = table,\n\n        -- standard lua variables\n        [\"_G\"] = {}\n    }\nend\n\n--\n-- Apply function to a record and arguments.\n--\n-- @param f the fully-qualified name of the function.\n-- @param r the record to be applied to the function.\n-- @param ... additional arguments to be applied to the function.\n-- @return result of the called function or nil.\n-- \nfunction apply_record(f, r, ...)\n\n    if f == nil then\n        error(\"function not found\", 2)\n    end\n    \n    if not sandboxed[f] then\n        setfenv(f,env_record())\n        sandboxed[f] = true\n    end\n\n    success, result = pcall(f, r, ...)\n    if success then\n        return result\n    else\n        error(result, 2)\n        return nil\n    end\nend\n\n--\n-- Apply function to an iterator and arguments.\n--\n-- @param f the fully-qualified name of the function.\n-- @param s the iterator to be applied to the function.\n-- @param ... additional arguments to be applied to the function.\n-- @return 0 on success, otherwise failure.\n-- \nfunction apply_stream(f, scope, istream, ostream, ...)\n\n    if f == nil then\n        error(\"function not found\", 2)\n        return 2\n    end\n    \n    --require(\"stream_ops\")\n\n    if not sandboxed[f] then\n        setfenv(f,env_record())\n        sandboxed[f] = true\n    end\n\n    local stream_ops = StreamOps_create();\n    success, result = pcall(f, stream_ops, ...)\n\n    -- info(\"apply_stream: success=%s, result=%s\", tostring(success), tostring(result))\n\n    if success then\n        local ops = StreamOps_select(result.ops, scope);\n        \n        -- Apply server operations to the stream\n        -- result => a stream_ops object\n        local values = StreamOps_apply(stream_iterator(istream), ops);\n\n        -- Iterate the stream of values from the computation\n        -- then pipe it to the ostream\n        for value in values do\n            -- info(\"value = %s\", tostring(value))\n            stream.write(ostream, value)\n        end\n\n        -- 0 is success\n        return 0\n    else\n        error(result, 2)\n        return 2\n    end\nend\n"
	const @"".LibStreamOps = "\n-- Lua Interface for Aerospike Record Stream Support\n--\n-- ======================================================================\n-- Copyright [2014] Aerospike, Inc.. Portions may be licensed\n-- to Aerospike, Inc. under one or more contributor license agreements.\n--\n-- Licensed under the Apache License, Version 2.0 (the \"License\");\n-- you may not use this file except in compliance with the License.\n-- You may obtain a copy of the License at\n--\n--  http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n-- ======================================================================\n\nlocal function check_limit(v)\n    return type(v) == 'number' and v >= 1000\nend\n\n--\n-- clone a table. creates a shallow copy of the table.\n--\nlocal function clone_table(t)\n    local out = {}\n    for k,v in pairs(t) do\n        out[k] = v\n    end\n    return out\nend\n\n--\n-- Clone a value.\n--\nlocal function clone(v)\n\n    local t = type(v)\n\n    if t == 'number' then\n        return v\n    elseif t == 'string' then\n        return v\n    elseif t == 'boolean' then\n        return v\n    elseif t == 'table' then\n        return clone_table(v)\n    elseif t == 'userdata' then\n        if v.__index == Map then\n            return map.clone(v)\n        elseif v.__index == List then\n            return list.clone(v)\n        end\n        return nil\n    end\n\n    return v\nend\n\n--\n-- Filter values\n-- @param next - a generator that produces the next value from a stream\n-- @param f - the function to transform each value\n--\nfunction filter( next, p )\n    -- done indicates if we exhausted the 'next' stream\n    local done = false\n\n    -- return a closure which the caller can use to get the next value\n    return function()\n        \n        -- we bail if we already exhausted the stream\n        if done then return nil end\n\n        -- find the first value which satisfies the predicate\n        for a in next do\n            if p(a) then\n                return a\n            end\n        end\n\n        done = true\n\n        return nil\n    end\nend\n\n--\n-- Transform values\n-- @param next - a generator that produces the next value from a stream\n-- @param f - the tranfomation operation\n--\nfunction transform( next, f )\n    -- done indicates if we exhausted the 'next' stream\n    local done = false\n\n    -- return a closure which the caller can use to get the next value\n    return function()\n        \n        -- we bail if we already exhausted the stream\n        if done then return nil end\n        \n        -- get the first value\n        local a = next()\n\n        -- apply the transformation\n        if a ~= nil then\n            return f(a)\n        end\n\n        done = true;\n\n        return nil\n    end\nend\n\n--\n-- Combines two values from an istream into a single value.\n-- @param next - a generator that produces the next value from a stream\n-- @param f - the reduction operation\n--\nfunction reduce( next, f )\n    -- done indicates if we exhausted the 'next' stream\n    local done = false\n\n    -- return a closure which the caller can use to get the next value\n    return function()\n\n\n        -- we bail if we already exhausted the stream\n        if done then return nil end\n        \n        -- get the first value\n        local a = next()\n\n        if a ~= nil then\n            -- get each subsequent value and reduce them\n            for b in next do\n                a = f(a,b)\n            end\n        end\n\n        -- we are done!\n        done = true\n\n        return a\n    end\nend\n\n--\n-- Aggregate values into a single value.\n-- @param next - a generator that produces the next value from a stream\n-- @param f - the aggregation operation\n--\nfunction aggregate( next, init, f )\n    -- done indicates if we exhausted the 'next' stream\n    local done = false\n\n    -- return a closure which the caller can use to get the next value\n    return function()\n\n        -- we bail if we already exhausted the stream\n        if done then return nil end\n\n        -- get the initial value\n        local a = clone(init)\n        \n        -- get each subsequent value and aggregate them\n        for b in next do\n            a = f(a,b)\n\n            -- check the size limit, if it is exceeded,\n            -- then return the value\n            if check_limit(a) then\n                return a\n            end\n        end\n\n        -- we are done!\n        done = true\n\n        return a\n    end\nend\n\n--\n-- as_stream iterator\n--\nfunction stream_iterator(s)\n    local done = false\n    return function()\n        if done then return nil end\n        local v = stream.read(s)\n        if v == nil then\n            done = true\n        end\n        return v;\n    end\nend\n\n\n\n-- ######################################################################################\n--\n-- StreamOps\n-- Builds a sequence of operations to be applied to a stream of values.\n--\n-- ######################################################################################\n\nStreamOps = {}\nStreamOps_mt = { __index = StreamOps }\n\n-- Op only executes on server\nlocal SCOPE_SERVER = 1\n\n-- Op only executes on client\nlocal SCOPE_CLIENT = 2\n\n-- Op can execute on either client or server\nlocal SCOPE_EITHER = 3\n\n-- Op executes on both client and server\nlocal SCOPE_BOTH = 4\n\n--\n-- Creates a new StreamOps using an array of ops\n-- \n-- @param ops an array of operations\n--\nfunction StreamOps_create()\n    local self = {}\n    setmetatable(self, StreamOps_mt)\n    self.ops = {}\n    return self\nend\n\nfunction StreamOps_apply(stream, ops, i, n)\n\n    -- if nil, then use default values\n    i = i or 1\n    n = n or #ops\n    \n    -- if index in list > size of list, then return the stream\n    if i > n then return stream end\n    \n    -- get the current operation\n    local op = ops[i]\n\n    -- apply the operation and get a stream or use provided stream\n    local s = op.func(stream, unpack(op.args)) or stream\n\n    -- move to the next operation\n    return StreamOps_apply(s, ops, i + 1, n)\nend\n\n\n--\n-- This selects the operations appropriate for a given scope.\n-- For the SERVER scope, it will select the first n ops until one of the ops\n-- is a CLIENT scope op.\n-- For the CLIENT scope, it will skip the first n ops that are SERVER scope \n-- ops, then it will take the remaining ops, including SERVER scoped ops.\n--\nfunction StreamOps_select(stream_ops, scope)\n    local server_ops = {}\n    local client_ops = {}\n    \n    local phase = SCOPE_SERVER\n    for i,op in ipairs(stream_ops) do\n        if phase == SCOPE_SERVER then\n            if op.scope == SCOPE_SERVER then\n                table.insert(server_ops, op)\n            elseif op.scope == SCOPE_EITHER then\n                table.insert(server_ops, op)\n            elseif op.scope == SCOPE_BOTH then\n                table.insert(server_ops, op)\n                table.insert(client_ops, op)\n                phase = SCOPE_CLIENT\n            end\n        elseif phase == SCOPE_CLIENT then\n            table.insert(client_ops, op)\n        end \n    end\n    \n    if scope == SCOPE_CLIENT then\n        return client_ops\n    else\n        return server_ops\n    end\nend\n\n\n\n-- \n-- OPS: [ OP, ... ]\n-- OP: {scope=SCOPE, name=NAME, func=FUNC, args=ARGS}\n-- SCOPE: ANY(0) | SERVER(1) | CLIENT(2) | \n-- NAME: FUNCTION NAME\n-- FUNC: FUNCTION POINTER\n-- ARGS: ARRAY OF ARGUMENTS\n--\n\n\nfunction StreamOps:aggregate(...)\n    table.insert(self.ops, { scope = SCOPE_SERVER, name = \"aggregate\", func = aggregate, args = {...}})\n    return self\nend\n\nfunction StreamOps:reduce(...)\n    table.insert(self.ops, { scope = SCOPE_BOTH, name = \"reduce\", func = reduce, args = {...}})\n    return self\nend\n\nfunction StreamOps:map(...)\n    table.insert(self.ops, { scope = SCOPE_EITHER, name = \"map\", func = transform, args = {...}})\n    return self\nend\n\nfunction StreamOps:filter(...)\n    table.insert(self.ops, { scope = SCOPE_EITHER, name = \"filter\", func = filter, args = {...}})\n    return self\nend\n\n-- stream : group(f)\n--\n-- Group By will return a Map of keys to a list of values. The key is determined by applying the \n-- function 'f' to each element in the stream.\n--\nfunction StreamOps:groupby(f)\n\n    local function _aggregate(m, v)\n        local k = f and f(v) or nil;\n        local l = m[k] or list()\n        list.append(l, v)\n        m[k] = l;\n        return m;\n    end\n\n    local function _merge(l1, l2)\n        local l = list.clone(l1)\n        for v in list.iterator(l2) do\n            list.append(l, v)\n        end\n        return l\n    end\n\n    function _reduce(m1, m2)\n        return map.merge(m1, m2, _merge)\n    end\n\n    return self : aggregate(map(), _aggregate) : reduce(_reduce)\nend\n"

$$
 _go_.o          0           0     0     644     60        `
go object windows amd64 go1.6.2 X:none

!
  go13ld ÿÿgo13ld